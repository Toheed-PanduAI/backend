from datetime import datetime
from database import db
from database.models import CreditTransaction, ThirdPartyAPICost
from fastapi import HTTPException
from typing import Optional
from uuid import uuid4 

CREDIT_COSTS = {
    "video_generation": 10,
    "video_editing": 2,
    "open_ai": 2,
    "eleven_labs" : 3,
    "stability": 5,
    "serp": 5
}

# To deduct credits
async def deduct_credits(user_id: str, amount: int, video_id: str, api_call_id:  Optional[str] = None):
    session =  db.start_session()
    async with session.start_transaction():
        user =  db.users_collection.find_one({"_id": user_id}, session=session)
        if user["credits"] < amount:
            raise HTTPException(status_code=400, detail="Insufficient credits")
        
        db.users_collection.update_one({"_id": user_id}, {"$inc": {"credits": -amount}}, session=session)
        transaction = CreditTransaction(user_id=user_id, amount=-amount, video_id=video_id, api_call_id=api_call_id)
        db.credit_transactions.insert_one(transaction.dict(by_alias=True), session=session)

# To assign credits
async def assign_credits(user_id: str, amount: int, video_id: str, api_call_id:  Optional[str] = None):
    session =  db.start_session()
    async with session.start_transaction():
        db.users_collection.update_one({"_id": user_id}, {"$inc": {"credits": amount}}, session=session)
        transaction = CreditTransaction(user_id=user_id, amount=amount, video_id=video_id, api_call_id=api_call_id)
        db.credit_transactions.insert_one(transaction.dict(by_alias=True), session=session)

# To get total video generated by a user
async def get_videos_generated_count(user_id: str):
    pipeline = [
        {"$match": {"user_id": user_id, "service_type": "video_generation"}},
        {"$count": "total_videos_generated"}
    ]
    result =  db.credit_transactions.aggregate(pipeline).to_list(length=1)
    return result[0]["total_videos_generated"] if result else 0

# To get credits used by a user monthly
async def get_monthly_credits_used(user_id: str, year: int, month: int):
    pipeline = [
        {"$match": {
            "user_id": user_id,
            "timestamp": {
                "$gte": datetime(year, month, 1),
                "$lt": datetime(year, month + 1, 1) if month < 12 else datetime(year + 1, 1, 1)
            }
        }},
        {"$group": {
            "_id": None,
            "total_credits_used": {"$sum": "$amount"}
        }}
    ]
    result =  db.credit_transactions.aggregate(pipeline).to_list(length=1)
    return abs(result[0]["total_credits_used"]) if result else 0

# To store credit transaction
def store_credit_transaction(user_id, video_id, api_call_id, credits, transaction_type, description: Optional[str] = None):
    db.credits_transaction_collection.insert_one({
        "credit_transaction_id": str(uuid4()),
        "user_id": user_id,
        "video_id": video_id,
        "api_call_id": api_call_id,
        "credits": credits,
        "transaction_type": transaction_type,
        "timestamp": datetime.utcnow(),
        "description": description
    })

# To store api usage
def store_api_usage(api_name, credit_cost, status, video_data):
    db.third_party_api_cost_collection.insert_one({
        "api_call_id": video_data["api_call_id"],
        "video_id": video_data["video_id"],
        "user_id": video_data["user_id"],
        "api_name": api_name,
        "credit_cost": credit_cost,
        "status": status,
        "created_at": datetime.utcnow()
    })

# To deduct user credits
def deduct_user_credits(user_id, amount):
    db.users_collection.update_one({"user_id": user_id}, {"$inc": {"remaining_credits": -amount}})

# To assign user credits
def assign_user_credits(user_id, amount):
    db.users_collection.update_one({"user_id": user_id}, {"$inc": {"credits": amount}})




# async def store_credit_transaction(
#     user_id: str,
#     video_id: str,
#     api_call_id: str,
#     amount: int,
#     transaction_type: str,
#     description: Optional[str] = None
# ) -> CreditTransaction:
    
#     # Validate transaction type
#     if transaction_type not in ["deduction", "addition"]:
#         raise ValueError("Invalid transaction type. Must be 'deduction' or 'addition'.")

#     # Create and store the transaction
#     transaction = CreditTransaction(
#         user_id=user_id,
#         video_id=video_id,
#         api_call_id=api_call_id,
#         amount=amount,
#         transaction_type=transaction_type,
#         timestamp=datetime.utcnow(),
#         description=description
#     )
#     db.credits_transaction_collection.insert_one(transaction.dict())

def filter_transactions_by_date_range(start_date: datetime, end_date: datetime):
    return [
        t for t in db.credits_transaction_collection.values()
        if start_date <= t.timestamp <= end_date
    ]

# To post data to third party api cost
async def post_third_party_api_cost(api_cost: ThirdPartyAPICost):
    data = api_cost.dict()
    data["api_call_id"] = str(uuid4())
    data["created_at"] = datetime.utcnow()
    
    result = db.third_party_api_cost_collection.insert_one(data)
    
    if not result.inserted_id:
        raise HTTPException(status_code=500, detail="Failed to create API cost entry")
    return api_cost

# To get data from third party api cost
async def get_third_party_api_cost(api_call_id: str):
    data =  db.third_party_api_cost_collection.find_one({"api_call_id": api_call_id})
    if not data:
        raise HTTPException(status_code=404, detail="API cost entry not found")
    return data

